// Code generated by array.go script; DO NOT EDIT.

package array

var _ Array = (*String)(nil)

type String struct {
	associative map[Scalar]int
	order       []string
	lastIndex   int
}

func NewString(vals ...string) String {
	a := String{
		associative: make(map[Scalar]int),
		order:       make([]string, 0),
		lastIndex:   0,
	}
	a.Add(vals...)
	return a
}

func (a *String) Add(vals ...string) *String {
	for _, v := range vals {
		k := NewScalar(a.lastIndex)
		a.add(k, v)
		a.lastIndex++
	}
	return a
}

func (a *String) Push(vals ...string) int {
	a.Add(vals...)
	return len(a.order)
}

func (a *String) Edit(k Scalar, v string) *String {
	if i, ok := a.associative[k]; ok {
		a.order[i] = v
	} else if i, ok := k.IntValue(); ok && i > a.lastIndex {
		a.lastIndex = i
		a.Add(v)
	} else {
		a.add(k, v)
	}
	return a
}

func (a *String) add(k Scalar, v string) {
	a.order = append(a.order, v)
	a.associative[k] = len(a.order) - 1
}

func (a String) At(k Scalar) string {
	if v, ok := a.associative[k]; ok {
		return a.order[v]
	}
	panic("undefined index " + k)
}

func (a String) Iter() []string {
	return a.order
}

type StringPair struct {
	K Scalar
	V string
}

func (a String) KeyIter() []StringPair {
	res := make([]StringPair, 0, len(a.order))
	for i, v := range a.order {
		res = append(res, StringPair{V: v})
		res[i].V = v
	}
	for k, v := range a.associative {
		res[v].K = k
	}
	return res
}

func (a String) Isset(k Scalar) bool {
	_, ok := a.associative[k]
	return ok
}

func (a *String) Unset(k Scalar) {
	i, ok := a.associative[k]
	if !ok {
		return
	}
	delete(a.associative, k)

	copy(a.order[i:], a.order[i+1:])
	a.order = a.order[:len(a.order)-1]
	for k, v := range a.associative {
		if v > i {
			a.associative[k] = v - 1
		}
	}
}

func (a String) Count() int {
	return len(a.order)
}
