// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
)

func main() {
	if len(os.Args) < 2 {
		log.Fatalf("Usage: array <data-type>")
	}
	typ := os.Args[1]
	b := []byte(typ)
	b[0] = bytes.ToUpper(b)[0]
	constructor := "New" + string(b)
	arrName := string(b)

	var writer bytes.Buffer

	writer.WriteString(`// Code generated by array.go script; DO NOT EDIT.

package array
`)

	writer.WriteString(fmt.Sprintf(`var _ Array = (*%s)(nil)

type %s struct {
	associative map[Scalar]int
	order       []%s
	lastIndex   int
}
`, arrName, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
func %s(vals ...%s) %s {
	a := %s{
		associative: make(map[Scalar]int),
		order:       make([]%s, 0),
		lastIndex:   0,
	}
	a.Add(vals...)
	return a
}
`, constructor, typ, arrName, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
func (a *%s) Add(vals ...%s) *%s {
	for _, v := range vals {
		k := NewScalar(a.lastIndex)
		a.add(k, v)
		a.lastIndex++
	}
	return a
}
`, arrName, typ, arrName))

	writer.WriteString(fmt.Sprintf(`
func (a *%s) Push(vals ...%s) int {
	a.Add(vals...)
	return len(a.order)
}
`, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
func (a *%s) Edit(k Scalar, v %s) *%s {
	if i, ok := a.associative[k]; ok {
		a.order[i] = v
	} else if i, ok := k.IntValue(); ok && i > a.lastIndex {
		a.lastIndex = i
		a.Add(v)
	} else {
		a.add(k, v)
	}
	return a
}
`, arrName, typ, arrName))

	writer.WriteString(fmt.Sprintf(`
func (a *%s) add(k Scalar, v %s) {
	a.order = append(a.order, v)
	a.associative[k] = len(a.order) - 1
}
`, arrName, typ))

	// TODO: Panic is too cruel, PHP uses "Notice".
	writer.WriteString(fmt.Sprintf(`
	func (a %s) At(k Scalar) %s {
		if v, ok := a.associative[k]; ok {
			return a.order[v]
		}
		panic("undefined index " + k)
	}
`, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
func (a %s) Iter() []%s {
	return a.order
}
`, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
type %sPair struct {
	K Scalar
	V %s
}
`, arrName, typ))

	writer.WriteString(fmt.Sprintf(`
func (a %s) KeyIter() []%sPair  {
	res := make([]%sPair, 0, len(a.order))
	for i, v := range a.order {
		res = append(res, %sPair{V: v})
		res[i].V = v
	}
	for k, v := range a.associative {
		res[v].K = k
	}
	return res
}
`, arrName, arrName, arrName, arrName))

	writer.WriteString(fmt.Sprintf(`
func (a %s) Isset(k Scalar) bool {
	_, ok := a.associative[k]
	return ok
}
`, arrName))

	writer.WriteString(fmt.Sprintf(`
func (a *%s) Unset(k Scalar) {
	i, ok := a.associative[k]
	if !ok {
		return
	}
	delete(a.associative, k)

	copy(a.order[i:], a.order[i+1:])
	a.order = a.order[:len(a.order)-1]
	for k, v := range a.associative {
		if v > i {
			a.associative[k] = v - 1
		}
	}
}
`, arrName))

	b, err := format.Source(writer.Bytes())
	if err != nil {
		log.Fatalf("Generating array for '%s': %v", typ, err)
	}

	if err := ioutil.WriteFile(typ+".go", b, 0644); err != nil {
		log.Fatal("Writing output file: %v", err)
	}
}
